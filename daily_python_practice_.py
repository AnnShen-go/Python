# -*- coding: utf-8 -*-
"""Daily Python Practice .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MQLdn_TTufOKIThdgS26FGfFYOsf1VMp

896. Monotonic Array- 20240629
"""

#V1
class Solution(object):
    def isMonotonic(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        return nums == sorted(nums) or nums == sorted(nums, reverse=True)

#V2
class Solution(object):
    def isMonotonic(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """


        increasing = decreasing = True

        for n in range(1, len(nums)):
            if nums[n] > nums[n - 1]:
                decreasing = False
            elif nums[n] < nums[n - 1]:
                increasing = False

        return increasing or decreasing

"""2215. Find the Difference of Two Arrays- 20240629"""

#V1
def findDifference(nums1, nums2):
    set1 = set(nums1)
    set2 = set(nums2)

    # Find distinct elements in nums1 not in nums2
    answer1 = list(set1 - set2)
    # Find distinct elements in nums2 not in nums1
    answer2 = list(set2 - set1)

    return [answer1, answer2]

#V2
class Solution(object):
    def findDifference(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[List[int]]
        """

        answer_1 = list({n1 for n1 in nums1 if n1 not in nums2})
        answer_2 = list({n2 for n2 in nums2 if n2 not in nums1})

        return [answer_1, answer_2]

"""DP:
https://web.ntnu.edu.tw/~algo/DynamicProgramming.html

70 Climb stairs- 20240706
"""

#V1 --> store the distinct ways in a dynamic table
def climbStairs(n: int) -> int:
    # 特殊情況處理
    if n == 0:
        return 1
    elif n == 1:
        return 1

    # 初始化 dp 數組
    dp = [0] * (n + 1)
    dp[0] = 1  # 到達第 0 級的方法數
    dp[1] = 1  # 到達第 1 級的方法數

    # 從第 2 級台階開始計算
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    # 返回到達第 n 級的方法數
    return dp[n]

# 示例使用
n = 5
print(climbStairs(n))  # 輸出: 8

#V2
class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        def climb(n):
             if n==1: #only one step option is availble
                 return 1
             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps
                 return 2
             return climb(n-1) + climb(n-2)
        return climb(n)

"""268. Missing Number- 20240709"""

class Solution(object):
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """


        x_all= 0
        x_num= 0

        for i in range(len(nums)+1):
            x_all ^= i
        for num in nums:
            x_num ^= num

        return  x_all ^ x_num

"""263. Ugly Number- 20240711"""

class Solution(object):
    def isUgly(self, n):
        """
        :type n: int
        :rtype: bool
        """

        if n<=0:
            return False

        for p in [2,3,5]:
            while n%p == 0:
                n //= p
        return n == 1

class Solution(object):
    def checkIfExist(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """

        for num in arr:
            if num%2 ==0 and num//2 in arr:
                return True

            else:
                return False

"""1925. count square sum triples- 20240712"""

def countSquareTriples(n):
    count = 0

    for a in range(1, n + 1):
        for b in range(1, n + 1):
            for c in range(1, n + 1):
                if a * a + b * b == c * c:
                    count += 1

    return count

# 示例使用
print(countSquareTriples(5))   # 輸出: 2
print(countSquareTriples(10))  # 輸出: 4

#V2
class Solution:
    def countTriples(self, n: int) -> int:
        c = 0
        for i in range(1, n+1):
            for j in range(i+1, n+1):
                sq = i*i + j*j
                r = int(sq ** 0.5)
                if ( r*r == sq and r <= n ):
                    c +=2
        return c

#V3
import math

class Solution:
    def countTriples(self, n: int) -> int:
        res = 0

        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                s = math.sqrt(i * i + j * j)
                if s.is_integer() and s <= n:
                    res += 2  # 计数 (i, j, s) 和 (j, i, s)

        return res

# 示例使用
sol = Solution()
print(sol.countTriples(5))   # 输出: 2
print(sol.countTriples(10))  # 输出: 4

"""2124. Check if All A's Appears Before All B's- 20240713"""

class Solution(object):
    def checkString(self, s):
        """
        :type s: str
        :rtype: bool
        """

        seen_b = False

        for char in s:
            if char == 'b':
                seen_b = True
            elif char == 'a' and seen_b:
                # 如果遇到 'a' 且已经见过 'b'
                return False

        return True

"""169. Majority Element- 20240713"""

class Solution(object):
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        for i in nums:
            if count(i)> len(nums)/2:
                return i

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = 0

        for num in nums:
            if count == 0:
                candidate = num

            if num == candidate:
                count += 1
            else:
                count -= 1

        return candidate

"""2843. Count Symmetric Integers- 20240716

"""

class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        ans = 0
        for n in range(low, high + 1):
            s = str(n)
            length = len(s)
            if length % 2 == 0 and sum(int(s[i]) for i in range(length // 2)) == sum(int(s[i]) for i in range(length // 2, length)):
                ans += 1
        return ans

# 示例使用
sol = Solution()
print(sol.countSymmetricIntegers(10, 100))  # 示例輸出

"""2413. Smallest Even Multiple- 20240717"""

class Solution(object):
    def smallestEvenMultiple(self, n):
        """
        :type n: int
        :rtype: int
        """

        if n%2== 0:
            return n
        elif n%2 != 0:
            return 2*n

import math

class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        return n if n % 2 == 0 else n * 2

"""1346. Check If N and Its Double Exist- 20240717"""

class Solution(object):
    def checkIfExist(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        seen = set()

        for num in arr:
            if 2 * num in seen or (num % 2 == 0 and num // 2 in seen):
                return True
            seen.add(num)

        return False

# 示例使用
sol = Solution()
print(sol.checkIfExist([10, 2, 5, 3]))  # 输出: True
print(sol.checkIfExist([7, 1, 14, 11]))  # 输出: True
print(sol.checkIfExist([3, 1, 7, 11]))  # 输出: False

"""2114. Maximum Number of Words Found in Sentences- 20240720

"""

class Solution(object):
    def mostWordsFound(self, sentences):
        """
        :type sentences: List[str]
        :rtype: int
        """
        return max(len(sentence.split()) for sentence in sentences)

# 示例使用
sol = Solution()
print(sol.mostWordsFound(["alice and bob love leetcode", "i think so too", "this is great thanks very much"]))  # 输出: 6

class Solution(object):
    def mostWordsFound(self, sentences):
        """
        :type sentences: List[str]
        :rtype: int
        """
        max_words = 0

        for sentence in sentences:
            # 计算每个句子的单词数
            word_count = len(sentence.split())
            # 更新最大单词数
            if word_count > max_words:
                max_words = word_count

        return max_words

# 示例使用
sol = Solution()
print(sol.mostWordsFound(["alice and bob love leetcode", "i think so too", "this is great thanks very much"]))  # 输出: 6

"""2160. Minimum Sum of Four Digit Number After Splitting Digits- 20240720"""

class Solution(object):
    def minimumSum(self, num):
        """
        :type num: int
        :rtype: int
        """

        digits = sorted([int(d) for d in str(num)])  # 将数字拆开并排序
        new1 = digits[0] * 10 + digits[2]  # 组合第一个和第三个数字
        new2 = digits[1] * 10 + digits[3]  # 组合第二个和第四个数字
        return new1 + new2  # 返回它们的和

"""1662. Check if two string arrays are equivalent
https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/
"""

class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        """
        :type word1: List[str]
        :type word2: List[str]
        :rtype: bool
        """

        first = ""
        second = ""

    # Concatenate all elements in word1
        for i in range(len(word1)):
            first += word1[i]

    # Concatenate all elements in word2
        for j in range(len(word2)):
            second += word2[j]

    # Compare the resulting strings
        return first == second

def arrayStringsAreEqual(word1, word2):
    # Concatenate all elements in word1 and word2
    string1 = ''.join(word1)
    string2 = ''.join(word2)

    # Compare the resulting strings
    return string1 == string2

"""867. Transpose Matrix
0729
"""

class Solution(object):
    def transpose(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """

        rows = len(matrix)
        cols = len(matrix[1])
        transposed_matrix = [[0] * rows for _ in range(cols)]

        for r in range(rows):
            for c in range(cols):
                transposed_matrix[c][r] = matrix[r][c]

        return transposed_matrix

"""804. Unique Morse Code Words
0730
"""

class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        morse_code = [".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",
                      ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",
                      "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."]

        transformations = set()

        for word in words:
            transformation = ''.join(morse_code[ord(char) - ord('a')] for char in word)
            transformations.add(transformation)

        return len(transformations)

def uniqueMorseRepresentations(words):
    morse_code_dict = {
        'a': ".-", 'b': "-...", 'c': "-.-.", 'd': "-..", 'e': ".", 'f': "..-.",
        'g': "--.", 'h': "....", 'i': "..", 'j': ".---", 'k': "-.-", 'l': ".-..",
        'm': "--", 'n': "-.", 'o': "---", 'p': ".--.", 'q': "--.-", 'r': ".-.",
        's': "...", 't': "-", 'u': "..-", 'v': "...-", 'w': ".--", 'x': "-..-",
        'y': "-.--", 'z': "--.."
    }

    transformations = set()

    for word in words:
        transformation = ''.join(morse_code_dict[char] for char in word)
        transformations.add(transformation)

    return len(transformations)

# Example usage
words = ["gin", "zen", "gig", "msg"]
print(uniqueMorseRepresentations(words))  # Output: 2

"""1464. Maximum Product of Two Elements in an Array
_20240801
"""

class Solution(object):
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        return (nums[-1] - 1) * (nums[-2] - 1)

"""1207. Unique Number of Occurrences_20240801"""

class Solution(object):
    def uniqueOccurrences(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """

        count = Counter(arr)

    # Step 2: Get the values of the occurrences
        occurrences = list(count.values())

    # Step 3: Check if the number of occurrences are unique
        return len(occurrences) == len(set(occurrences))

def uniqueOccurrences(arr):
    count_dict = {}

    # Step 1: Count occurrences of each number in the array
    for num in arr:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1

    # Step 2: Check if all counts are unique
    count_set = set()
    for count in count_dict.values():
        if count in count_set:
            return False
        count_set.add(count)

    return True

# Example usage:
arr = [1, 2, 2, 1, 1, 3]
print(uniqueOccurrences(arr))  # Output: True

"""832. Flipping an Image 0807"""

class Solution(object):
    def flipAndInvertImage(self, image):
        """
        :type image: List[List[int]]
        :rtype: List[List[int]]
        """

        for x in range(len(image)):
            image[x] = image[x][::-1]
            image[x] = [1 - y for y in image[x]]
        return image

class Solution(object):
    def flipAndInvertImage(self, image):
        """
        :type image: List[List[int]]
        :rtype: List[List[int]]
        """

        for row in image:
        # Flip the row horizontally
            row.reverse()
        # Invert the row
            for i in range(len(row)):
                row[i] = 1 - row[i]
        return image

"""2828. Check if a String Is an Acronym of Words 0807"""

class Solution(object):
    def isAcronym(self, words, s):
        """
        :type words: List[str]
        :type s: str
        :rtype: bool
        """
        y= ""

        for x in range(len(words)):
            y += (words[x][0])

        return y == s

"""1732. Find the Highest Altitude 0808"""

class Solution(object):
    def largestAltitude(self, gain):
        """
        :type gain: List[int]
        :rtype: int
        """

        altitudes = [0]
        current_altitude = 0

        for x in gain:
            current_altitude += x
            altitudes.append(current_altitude)

        return max(altitudes)

class Solution(object):
    def largestAltitude(self, gain):
        """
        :type gain: List[int]
        :rtype: int
        """
        r = [0]
        for i in gain:
            r.append(r[-1]+i)
        return max(r)

"""2824. Count Pairs Whose Sum is Less than Target 0812"""

class Solution(object):
    def countPairs(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """

        pairs=0
        for i in range(0, len(nums)):
            for j in range(0, len(nums)):
                if  i != j and i < j and nums[i] + nums[j] < target:
                    pairs +=1
        return pairs

        # pairs = 0

        # for i in range(len(nums)):
        #     for j in range(i + 1, len(nums)):  # Ensure j starts after i
        #         if nums[i] + nums[j] < target:
        #             pairs += 1
        # return pairs

nums.sort()
        left, right = 0, len(nums) - 1
        pairs = 0

        while left < right:
            # Check if the sum of the pair is less than the target
            if nums[left] + nums[right] < target:
                # If the sum is less than target, all pairs between left and right are valid
                pairs += (right - left)
                left += 1
            else:
                right -= 1

        return pairs

Binary approach:

        n = len(nums)
        nums.sort()
        pairs = 0

        for i in range(n):
            low = i + 1
            high = n - 1

            while low <= high:
                j = (low + high) // 2

                if nums[i] + nums[j] < target:
                    pairs += j - low + 1
                    low = j + 1
                else:
                    high = j - 1

        return pairs

"""228. Summary Ranges 0814"""

class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        ranges = [] # [start, end] or [x, y]
        for n in nums:
            if ranges and ranges[-1][1] == n-1:
                ranges[-1][1] = n
            else:
                ranges.append([n, n])

        return [f'{x}->{y}' if x != y else f'{x}' for x, y in ranges]

class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:

        # if not nums:
        #     return []

        summary = []
        start = nums[0]  # 記錄範圍的起點

        for i in range(1, len(nums)):
            if nums[i] != nums[i - 1] + 1:
                # 檢查當前範圍是否只有一個元素
                if start == nums[i - 1]:
                    summary.append(str(start))
                else:
                    summary.append(f"{start}->{nums[i - 1]}")
                start = nums[i]  # 更新起點為新範圍的起點

        # 處理最後一個範圍
        if start == nums[-1]:
            summary.append(str(start))
        else:
            summary.append(f"{start}->{nums[-1]}")

        return summary

"""217. Contains Duplicate 0816"""

hset=set()
        for ch in nums:
            if ch in hset:
                return True
            hset.add(ch)
        return False

"""1431. Kids With the Greatest Number of Candies 0816"""

class Solution(object):
    def kidsWithCandies(self, candies, extraCandies):
        """
        :type candies: List[int]
        :type extraCandies: int
        :rtype: List[bool]
        """
        output=[]

        for x in candies:
            if x + extraCandies >= max(candies):
                output.append(True)
            else:
                output.append(False)
        return output

"""1436. Destination City 0816"""

class Solution(object):
    def destCity(self, paths):
        """
        :type paths: List[List[str]]
        :rtype: str
        """

        start_cities = set()

        # 将每个路径的起点加入到 start_cities 集合中
        for path in paths:
            start_cities.add(path[0])

        # 查找终点城市，它不在 start_cities 中
        for path in paths:
            if path[1] not in start_cities:
                return path[1]

# Arthur's'

class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        tbl = dict()
        for item in paths:
            if item[0] not in tbl.keys():
                tbl[item[0]] = [item[1]]
            else:
                tbl[item[0]].append(item[1])
        for item in paths:
            if item[1] not in tbl.keys():
                return item[1]